package grocery

import (
	"fmt"
	"github.com/aodin/csv2"
	"github.com/aodin/denver/parsing"
	"os"
	"strconv"
)

// ParseFoodStoresCSV parses the CSV downloaded from data.denvergov.org:
// http://data.denvergov.org/dataset/city-and-county-of-denver-food-stores
// The rawStore is just strings because there are too many empty fields
// throughout the food stores CSV to enforce schema.
func ParseFoodStoresCSV(path string) (stores []rawStore, err error) {
	file, err := os.Open(path)
	if err != nil {
		return
	}
	defer file.Close()

	r := csv.NewReader(file)

	// Skip the header
	_, err = r.Read()
	if err != nil {
		return
	}

	err = r.Unmarshal(&stores)
	return
}

// ParseFoodStoresCSV parses the CSV generated by converting the raw
// download.
func ParseConvertedStoresCSV(path string) (stores []Store, err error) {
	file, err := os.Open(path)
	if err != nil {
		return
	}
	defer file.Close()

	r := csv.NewReader(file)

	// Skip the header
	_, err = r.Read()
	if err != nil {
		return
	}

	err = r.Unmarshal(&stores)
	return
}

// ConvertRawStore enforces types on a rawStore and returns a Store.
// It will error if any of the following fields are missing (which they may
// be in a regular CSV download):
// * Latitude or longitude
// * Name
// * Address
func ConvertRawStore(raw rawStore) (store Store, err error) {
	// Fields that can be copied
	store.Name = raw.Name
	if store.Name == "" {
		err = fmt.Errorf("store is missing name")
		return
	}

	store.Phone = raw.Phone
	store.Hours = raw.Hours
	store.AddressLine1 = raw.Address
	store.AddressLine2 = raw.Address2
	store.City = raw.City
	store.State = raw.State
	store.ZIP = raw.ZIP

	// Composite fields
	store.Address = parsing.ConcatIfNotEmpty(
		" ",
		raw.Address,
		raw.Address2,
		raw.City,
		raw.State,
		raw.ZIP,
	)

	// Fields that are replaced
	store.Type = types[raw.Type]
	store.BranchStatus = branch[raw.BranchStatus]
	store.SquareFootage = sqrt[raw.SquareFeet]

	// Ints (optional)
	store.SIC = parsing.ParseInt64OrDefault(raw.SIC, 0)
	store.NAICS = parsing.ParseInt64OrDefault(raw.NAICS, 0)
	store.SalesVolume = parsing.ParseInt64OrDefault(raw.Sales, 0)
	store.Employees = parsing.ParseInt64OrDefault(raw.Employees, 0)

	// Floats (required)
	store.Latitude, err = strconv.ParseFloat(raw.Latitude, 64)
	if err != nil {
		err = fmt.Errorf("failed to parse latitude: %s", err)
		return
	}
	store.Longitude, err = strconv.ParseFloat(raw.Longitude, 64)
	if err != nil {
		err = fmt.Errorf("failed to parse longitude: %s", err)
		return
	}

	// Booleans
	store.AcceptsSnap = parsing.ParseYesOrNo(raw.Snap)
	return
}

// ConvertRawStores will convert all the given rawStores to Stores.
// It will return on any error.
func ConvertRawStores(raws []rawStore) ([]Store, error) {
	stores := make([]Store, len(raws))
	var err error
	for i, raw := range raws {
		stores[i], err = ConvertRawStore(raw)
		if err != nil {
			return stores, fmt.Errorf("failed to parse index %d: %s", i, err)
		}
	}
	return stores, err
}

// ConvertRawStores will convert the given rawStores to Stores, dropping
// any that error.
func ConvertRawStoresDropErrors(raws []rawStore) []Store {
	stores := make([]Store, 0)
	for _, raw := range raws {
		store, err := ConvertRawStore(raw)
		if err == nil {
			stores = append(stores, store)
		}
	}
	return stores
}
